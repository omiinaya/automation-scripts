<#
.SYNOPSIS
    Script generation module for creating standardized CIS audit and remediation scripts.
.DESCRIPTION
    Provides template-based script creation from JSON recommendations.
    Generates standardized audit and remediation scripts with consistent patterns.
.NOTES
    File Name      : ScriptGenerator.psm1
    Author         : System Administrator
    Prerequisite   : PowerShell 5.1 or later
    Dependencies   : ConfigurationManager, CISFramework
    
.EXAMPLE
    $template = Get-CISScriptTemplate -ScriptType "Audit" -CIS_ID "1.1.1"
    New-CISScript -Template $template -OutputPath "audits\1.1.1-audit-password-history.ps1"
.EXAMPLE
    Generate-CISScriptsFromJSON -JsonPath "docs\json\cis_section_1.json" -OutputDirectory "windows\deferred\security\audits"
#> 

# Import required modules
Import-Module "$PSScriptRoot\ConfigurationManager.psm1" -Force -WarningAction SilentlyContinue
Import-Module "$PSScriptRoot\CISFramework.psm1" -Force -WarningAction SilentlyContinue

# Script templates
$Script:CISScriptTemplates = @{
    AuditTemplate = @'
# Audit: {Title} on Windows
# CIS Benchmark: {CIS_ID} ({Profile}) {Title}
# Generated by CIS Script Generator
# Timestamp: {Timestamp}

[CmdletBinding()]
param()

$VerboseOutput = $PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose')

# Use centralized script execution
$result = Invoke-CISScript -ScriptType "Audit" -CIS_ID "{CIS_ID}" -VerboseOutput:$VerboseOutput -ScriptBlock {
    # Audit logic based on CIS recommendation
    {AuditLogic}
}

# Return the structured audit result
return $result
'@

    RemediationTemplate = @'
# Remediation: {Title} on Windows
# CIS Benchmark: {CIS_ID} ({Profile}) {Title}
# Generated by CIS Script Generator
# Timestamp: {Timestamp}

[CmdletBinding()]
param(
    [switch]$AutoConfirm
)

$VerboseOutput = $PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose')

# Use centralized script execution
$result = Invoke-CISScript -ScriptType "Remediation" -CIS_ID "{CIS_ID}" -VerboseOutput:$VerboseOutput -AutoConfirm:$AutoConfirm -ScriptBlock {
    # Remediation logic based on CIS recommendation
    {RemediationLogic}
}

# Return the structured remediation result
return $result
'@

    ServiceToggleTemplate = @'
# Service Toggle: {ServiceDisplayName} on Windows
# Generated by CIS Script Generator
# Timestamp: {Timestamp}

[CmdletBinding()]
param()

$VerboseOutput = $PSCmdlet.MyInvocation.BoundParameters.ContainsKey('Verbose')

# Use centralized script execution
$result = Invoke-CISScript -ScriptType "ServiceToggle" -ServiceName "{ServiceName}" -ServiceDisplayName "{ServiceDisplayName}" -VerboseOutput:$VerboseOutput -ScriptBlock {
    # Service toggle logic
    {ServiceToggleLogic}
}

# Return the structured service toggle result
return $result
'@
}

# Function to get script template
function Get-CISScriptTemplate {
    <#
    .SYNOPSIS
        Returns a script template for the specified script type.
    .DESCRIPTION
        Provides standardized script templates for audit, remediation, and service toggle scripts.
    .PARAMETER ScriptType
        Type of script template (Audit, Remediation, ServiceToggle).
    .PARAMETER CIS_ID
        CIS benchmark ID for audit/remediation scripts.
    .PARAMETER ServiceName
        Service name for service toggle scripts.
    .PARAMETER ServiceDisplayName
        Service display name for service toggle scripts.
    .EXAMPLE
        $template = Get-CISScriptTemplate -ScriptType "Audit" -CIS_ID "1.1.1"
    .OUTPUTS
        Script template string.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [ValidateSet("Audit", "Remediation", "ServiceToggle")]
        [string]$ScriptType,
        
        [string]$CIS_ID,
        
        [string]$ServiceName,
        
        [string]$ServiceDisplayName
    )
    
    switch ($ScriptType) {
        "Audit" {
            $template = $Script:CISScriptTemplates.AuditTemplate
            
            # Get CIS recommendation for audit template
            if ($CIS_ID) {
                $recommendation = Get-CISRecommendation -CIS_ID $CIS_ID
                
                if ($recommendation) {
                    $template = $template -replace "\{Title\}", $recommendation.title
                    $template = $template -replace "\{CIS_ID\}", $recommendation.cis_id
                    $template = $template -replace "\{Profile\}", $recommendation.profile
                }
            }
            
            # Generate audit logic based on CIS ID pattern
            $auditLogic = Generate-AuditLogic -CIS_ID $CIS_ID
            $template = $template -replace "\{AuditLogic\}", $auditLogic
        }
        
        "Remediation" {
            $template = $Script:CISScriptTemplates.RemediationTemplate
            
            # Get CIS recommendation for remediation template
            if ($CIS_ID) {
                $recommendation = Get-CISRecommendation -CIS_ID $CIS_ID
                
                if ($recommendation) {
                    $template = $template -replace "\{Title\}", $recommendation.title
                    $template = $template -replace "\{CIS_ID\}", $recommendation.cis_id
                    $template = $template -replace "\{Profile\}", $recommendation.profile
                }
            }
            
            # Generate remediation logic based on CIS ID pattern
            $remediationLogic = Generate-RemediationLogic -CIS_ID $CIS_ID
            $template = $template -replace "\{RemediationLogic\}", $remediationLogic
        }
        
        "ServiceToggle" {
            $template = $Script:CISScriptTemplates.ServiceToggleTemplate
            
            if ($ServiceName) {
                $template = $template -replace "\{ServiceName\}", $ServiceName
            }
            
            if ($ServiceDisplayName) {
                $template = $template -replace "\{ServiceDisplayName\}", $ServiceDisplayName
            }
            
            # Generate service toggle logic
            $serviceToggleLogic = Generate-ServiceToggleLogic -ServiceName $ServiceName
            $template = $template -replace "\{ServiceToggleLogic\}", $serviceToggleLogic
        }
    }
    
    # Add timestamp
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $template = $template -replace "\{Timestamp\}", $timestamp
    
    return $template
}

# Function to generate audit logic based on CIS ID pattern
function Generate-AuditLogic {
    param(
        [string]$CIS_ID
    )
    
    # Generate audit logic based on CIS ID pattern
    switch -Wildcard ($CIS_ID) {
        "1.1.*" {
            return @'
    # Password policy audit
    $auditResult = Invoke-CISAudit -CIS_ID "{CIS_ID}" -AuditType "Registry" -RegistryPath "HKLM:\SOFTWARE\Policies\Microsoft\Windows" -RegistryValueName "PasswordHistorySize" -VerboseOutput:$VerboseOutput
    return $auditResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
        "2.2.*" {
            return @'
    # User rights assignment audit
    $auditResult = Invoke-CISAudit -CIS_ID "{CIS_ID}" -AuditType "Custom" -VerboseOutput:$VerboseOutput -CustomScriptBlock {
        # Custom user rights audit logic
        return @{
            CurrentValue = "Administrators"
            Source = "Local Security Policy"
            Details = "User rights assignment audit"
        }
    }
    return $auditResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
        "5.*" {
            return @'
    # Service configuration audit
    $serviceName = Get-ServiceNameFromCISID -CIS_ID "{CIS_ID}"
    $auditResult = Invoke-CISAudit -CIS_ID "{CIS_ID}" -AuditType "Service" -ServiceName $serviceName -VerboseOutput:$VerboseOutput
    return $auditResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
        default {
            return @'
    # Generic registry audit
    $auditResult = Invoke-CISAudit -CIS_ID "{CIS_ID}" -AuditType "Registry" -RegistryPath "HKLM:\SOFTWARE\Policies\Microsoft\Windows" -RegistryValueName "SettingName" -VerboseOutput:$VerboseOutput
    return $auditResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
    }
}

# Function to generate remediation logic based on CIS ID pattern
function Generate-RemediationLogic {
    param(
        [string]$CIS_ID
    )
    
    # Generate remediation logic based on CIS ID pattern
    switch -Wildcard ($CIS_ID) {
        "1.1.*" {
            return @'
    # Password policy remediation
    $remediationResult = Invoke-CISRemediation -CIS_ID "{CIS_ID}" -RemediationType "Registry" -RegistryPath "HKLM:\SOFTWARE\Policies\Microsoft\Windows" -RegistryValueName "PasswordHistorySize" -RegistryValueData 24 -RegistryValueType "DWord" -VerboseOutput:$VerboseOutput -AutoConfirm:$AutoConfirm
    return $remediationResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
        "5.*" {
            return @'
    # Service remediation
    $serviceName = Get-ServiceNameFromCISID -CIS_ID "{CIS_ID}"
    $serviceResult = Set-ServiceCompliance -ServiceName $serviceName -ServiceDisplayName "Service" -ComplianceState "NonCompliant" -VerboseOutput:$VerboseOutput
    return $serviceResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
        default {
            return @'
    # Generic registry remediation
    $remediationResult = Invoke-CISRemediation -CIS_ID "{CIS_ID}" -RemediationType "Registry" -RegistryPath "HKLM:\SOFTWARE\Policies\Microsoft\Windows" -RegistryValueName "SettingName" -RegistryValueData 1 -RegistryValueType "DWord" -VerboseOutput:$VerboseOutput -AutoConfirm:$AutoConfirm
    return $remediationResult
'@ -replace "\{CIS_ID\}", $CIS_ID
        }
    }
}

# Function to generate service toggle logic
function Generate-ServiceToggleLogic {
    param(
        [string]$ServiceName
    )
    
    return @'
    # Service toggle operation
    $serviceResult = Set-ServiceCompliance -ServiceName "{ServiceName}" -ServiceDisplayName "Service" -ComplianceState "NonCompliant" -VerboseOutput:$VerboseOutput
    return $serviceResult
'@ -replace "\{ServiceName\}", $ServiceName
}

# Function to create a new CIS script
function New-CISScript {
    <#
    .SYNOPSIS
        Creates a new CIS script from a template.
    .DESCRIPTION
        Generates standardized scripts with consistent patterns and error handling.
    .PARAMETER Template
        Script template string.
    .PARAMETER OutputPath
        Path where the script will be saved.
    .PARAMETER Overwrite
        Overwrite existing file.
    .EXAMPLE
        $template = Get-CISScriptTemplate -ScriptType "Audit" -CIS_ID "1.1.1"
        New-CISScript -Template $template -OutputPath "audits\1.1.1-audit-password-history.ps1"
    .OUTPUTS
        Boolean indicating success.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$Template,
        
        [Parameter(Mandatory=$true)]
        [string]$OutputPath,
        
        [switch]$Overwrite
    )
    
    try {
        # Ensure output directory exists
        $outputDir = Split-Path $OutputPath -Parent
        if (-not (Test-Path $outputDir)) {
            New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
        }
        
        # Check if file exists
        if ((Test-Path $OutputPath) -and (-not $Overwrite)) {
            Write-Warning "Script file already exists: $OutputPath"
            return $false
        }
        
        # Write the script
        $Template | Out-File -FilePath $OutputPath -Encoding UTF8 -Force:$Overwrite
        
        Write-StatusMessage -Message "Script created successfully: $OutputPath" -Type Success
        return $true
        
    } catch {
        Write-Error "Failed to create script: $_"
        return $false
    }
}

# Function to generate scripts from JSON recommendations
function Generate-CISScriptsFromJSON {
    <#
    .SYNOPSIS
        Generates CIS scripts from JSON recommendation files.
    .DESCRIPTION
        Creates standardized audit and remediation scripts from CIS JSON recommendations.
    .PARAMETER JsonPath
        Path to JSON file containing CIS recommendations.
    .PARAMETER OutputDirectory
        Directory where scripts will be saved.
    .PARAMETER ScriptTypes
        Types of scripts to generate (Audit, Remediation).
    .PARAMETER Overwrite
        Overwrite existing files.
    .EXAMPLE
        Generate-CISScriptsFromJSON -JsonPath "docs\json\cis_section_1.json" -OutputDirectory "windows\deferred\security\audits"
    .OUTPUTS
        Array of generated script paths.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [string]$JsonPath,
        
        [Parameter(Mandatory=$true)]
        [string]$OutputDirectory,
        
        [ValidateSet("Audit", "Remediation")]
        [string[]]$ScriptTypes = @("Audit", "Remediation"),
        
        [switch]$Overwrite
    )
    
    try {
        # Validate JSON file
        if (-not (Test-Path $JsonPath)) {
            Write-Error "JSON file not found: $JsonPath"
            return @()
        }
        
        # Load JSON content
        $jsonContent = Get-Content $JsonPath -Raw | ConvertFrom-Json
        
        if (-not $jsonContent) {
            Write-Error "Failed to parse JSON file: $JsonPath"
            return @()
        }
        
        $generatedScripts = @()
        
        # Generate scripts for each recommendation
        foreach ($recommendation in $jsonContent) {
            $cisID = $recommendation.cis_id
            
            foreach ($scriptType in $ScriptTypes) {
                # Generate script filename
                $filename = "$cisID-$($scriptType.ToLower())-$($recommendation.title.ToLower().Replace(' ', '-').Replace('\'', '').Replace('"', ''))"
                $filename = $filename -replace '[^a-zA-Z0-9\-\._]', ''
                $filename += ".ps1"
                
                $outputPath = Join-Path $OutputDirectory $filename
                
                # Get template
                $template = Get-CISScriptTemplate -ScriptType $scriptType -CIS_ID $cisID
                
                # Create script
                if (New-CISScript -Template $template -OutputPath $outputPath -Overwrite:$Overwrite) {
                    $generatedScripts += $outputPath
                }
            }
        }
        
        Write-StatusMessage -Message "Generated $($generatedScripts.Count) scripts from $($jsonContent.Count) recommendations" -Type Success
        return $generatedScripts
        
    } catch {
        Write-Error "Failed to generate scripts from JSON: $_"
        return @()
    }
}

# Helper function to map CIS ID to service name
function Get-ServiceNameFromCISID {
    param(
        [string]$CIS_ID
    )
    
    # Service mapping based on CIS ID patterns
    $serviceMapping = @{
        "5.4" = "MapsBroker"
        "5.5" = "lfsvc"
        "5.6" = "BDESVC"
        "5.7" = "Spooler"
        "5.8" = "RemoteRegistry"
        "5.9" = "WSearch"
    }
    
    if ($serviceMapping.ContainsKey($CIS_ID)) {
        return $serviceMapping[$CIS_ID]
    }
    
    # Default service name
    return "UnknownService"
}

# Export the module members
Export-ModuleMember -Function Get-CISScriptTemplate, New-CISScript, Generate-CISScriptsFromJSON, Get-ServiceNameFromCISID